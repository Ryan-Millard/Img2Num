name: Issue Take/Untake Workflow

on:
  issues:
    types: [opened]
  issue_comment:
    types: [created]
  schedule:
    - cron: '0 0 * * 0' # weekly cleanup (UTC)

permissions:
  contents: read
  issues: write

jobs:
  # Post initial instructions and ensure label exists
  issue_instructions:
    if: github.event_name == 'issues' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    steps:
      - name: Post instructions and ensure 'taken' label exists
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = context.payload.issue.number;
            const takenLabel = 'taken';

            // Ensure label exists (best-effort)
            try {
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: takenLabel,
                color: 'ff0000',
                description: 'Issue is currently claimed'
              });
            } catch (e) {
              // ignore if label already exists
            }

            // Instructions comment (no meta marker here; preserves commit guide rules)
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issueNumber,
              body: [
                "üëã Thanks for opening this issue!",
                "",
                "> [!TIP]",
                "> # Claiming rules",
                "> - Only one claim at a time (the claimer can invite others)",
                "> - Comment `/take` to claim the issue",
                "> \t- You may invite collaborators: e.g., `/take @user1 @user2`",
                "> - Comment `/untake` to release (or to remove yourself if you've been invited)",
                "> \t- You may remove collaborators: e.g., `/untake @user1 @user2`",
                "> - Claims expire after **3 weeks** of inactivity (automatically)",
                ""
              ].join("\n")
            });

  # Handle /take and /untake comments (single bot comment per action)
  take_untake:
    if: github.event_name == 'issue_comment'
    runs-on: ubuntu-latest
    steps:
      - name: Handle /take and /untake
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (!github) throw new Error("github object is undefined");
            const comment = context.payload.comment;
            if (!comment) return;
            const commenter = comment.user.login;
            const body = (comment.body || '').trim();
            const issueNumber = context.payload.issue.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const takenLabel = 'taken';
            const BOT_LOGIN = 'github-actions[bot]';
            const MARKER_PREFIX = '<!-- take-meta:';
            const EXPIRE_MS = 21 * 24 * 60 * 60 * 1000; // 3 weeks

            const isTake = /^\/take(\s|$)/i.test(body);
            const isUntake = /^\/untake(\s|$)/i.test(body);
            if (!isTake && !isUntake) return;

            // Helper: create a plain human-visible comment (used only for short replies where meta isn't changing)
            async function quickReply(text) {
              await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: text });
            }

            // Get issue data and comments
            const issueResp = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
            const labels = (issueResp.data.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const hasTakenLabel = labels.includes(takenLabel);

            const commentsResp = await github.rest.issues.listComments({ owner, repo, issue_number: issueNumber, per_page: 200 });
            const comments = commentsResp.data || [];

            // Find latest bot comment containing our marker (we only read; we never edit)
            const botCommentsWithMarker = comments
              .filter(c => c.user && c.user.login === BOT_LOGIN && (c.body || '').includes(MARKER_PREFIX))
              .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
            const latestBotComment = botCommentsWithMarker.length ? botCommentsWithMarker[botCommentsWithMarker.length - 1] : null;

            // Parse meta from latest bot comment if present
            let meta = { owner: null, members: [], ts: 0 };
            if (latestBotComment) {
              try {
                const start = latestBotComment.body.indexOf(MARKER_PREFIX);
                const end = latestBotComment.body.indexOf('-->', start);
                const jsonText = latestBotComment.body.slice(start + MARKER_PREFIX.length, end).trim();
                meta = JSON.parse(jsonText);
              } catch (e) {
                meta = { owner: null, members: [], ts: 0 };
              }
            }

            const now = Date.now();

            // If meta is stale, expire it on interaction
            if (meta && meta.owner && meta.ts && (now - meta.ts) > EXPIRE_MS) {
              if (hasTakenLabel) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: takenLabel });
                } catch (e) { /* ignore */ }
              }
              // single human-visible expiry comment
              await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: `‚ö†Ô∏è The claim by @${meta.owner} has expired after 3 weeks of inactivity. The issue is now free to be taken.` });
              // create a new bot meta comment that resets state (we do NOT edit old comments)
              const resetMeta = { owner: null, members: [], ts: 0 };
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: `${MARKER_PREFIX}${JSON.stringify(resetMeta)} -->\n\nThis issue is currently unclaimed.`
              });
              // update local meta
              meta = resetMeta;
            }

            // Persist meta by creating a new bot comment containing both the marker and a human message.
            // This function creates exactly ONE comment and handles the label add/remove.
            async function persistMetaAndComment(metaObj, ensureLabel, humanMessage) {
              const botBody = `${MARKER_PREFIX}${JSON.stringify(metaObj)} -->\n\n${humanMessage}`;
              await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: botBody });

              if (ensureLabel) {
                try {
                  await github.rest.issues.addLabels({ owner, repo, issue_number: issueNumber, labels: [takenLabel] });
                } catch (e) { /* ignore */ }
              } else {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: takenLabel });
                } catch (e) { /* ignore */ }
              }
            }

            // parse mentions in the /take comment
            const mentions = [...(body.matchAll(/@([A-Za-z0-9-]+)/g))].map(m => m[1]);
            const newMentions = mentions.filter(u => u !== commenter);

            // ---------- /take ----------
            if (isTake) {
              if (!meta.owner) {
                // claim the issue
                meta.owner = commenter;
                meta.members = Array.from(new Set([...(meta.members || []), ...newMentions]));
                meta.ts = Date.now();

                const humanMsg = meta.members.length > 0
                  ? `‚úÖ This issue has been taken by @${meta.owner}, with ${meta.members.map(m => `@${m}`).join(', ')} invited to collaborate.`
                  : `‚úÖ This issue has been taken by @${meta.owner}. Comment \`/untake\` to release it.`;

                await persistMetaAndComment(meta, true, humanMsg);
                return;
              }

              // already claimed
              if (meta.owner === commenter) {
                // owner re-issuing /take: allow adding new collaborators if they @mention them
                if (newMentions.length === 0) {
                  // single short reply (no meta change)
                  await quickReply(`‚ÑπÔ∏è You have already taken this issue.`);
                } else {
                  meta.members = Array.from(new Set([...(meta.members || []), ...newMentions]));
                  meta.ts = Date.now(); // refresh timestamp when owner interacts
                  const humanMsg = `üîó @${commenter} has invited ${newMentions.map(u => '@'+u).join(', ')} to this issue.`;
                  await persistMetaAndComment(meta, true, humanMsg);
                }
              } else {
                // someone else attempted to take -> single reply
                await quickReply(`‚ö†Ô∏è Sorry, this issue is already claimed by @${meta.owner}.`);
              }
              return;
            }

            // ---------- /untake ----------
            if (isUntake) {
              if (!meta.owner) {
                await quickReply(`‚ÑπÔ∏è This issue is not currently claimed.`);
                return;
              }

              const mentioned = mentions[0]; // only one makes sense here

              // OWNER removing a collaborator
              if (meta.owner === commenter && mentioned) {
                if (!meta.members.includes(mentioned)) {
                  await quickReply(`‚ÑπÔ∏è @${mentioned} is not a collaborator on this issue.`);
                  return;
                }

                meta.members = meta.members.filter(m => m !== mentioned);
                meta.ts = Date.now();

                await persistMetaAndComment(
                  meta,
                  true,
                  `üö´ @${commenter} has removed @${mentioned} from this issue.`
                );
                return;
              }

              // OWNER unclaiming entire issue
              if (meta.owner === commenter && !mentioned) {
                meta = { owner: null, members: [], ts: 0 };

                await persistMetaAndComment(
                  meta,
                  false,
                  `üö´ @${commenter} has unclaimed this issue. It is now free for others.`
                );
                return;
              }

              // MEMBER removing themselves
              if (meta.members.includes(commenter) && !mentioned) {
                meta.members = meta.members.filter(m => m !== commenter);
                meta.ts = Date.now();

                await persistMetaAndComment(
                  meta,
                  true,
                  `üö´ @${commenter} has removed themselves from this issue. It remains claimed by @${meta.owner}.`
                );
                return;
              }

              // Anything else is invalid
              await quickReply(
                `‚ö†Ô∏è You cannot modify this claim. Only the owner can remove collaborators, and members may remove themselves.`
              );
              return;
            }

  # Weekly cleanup job (runs on schedule) ‚Äî creates new comments only (no edits)
  cleanup:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Expire stale claims (weekly)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const takenLabel = 'taken';
            const BOT_LOGIN = 'github-actions[bot]';
            const MARKER_PREFIX = '<!-- take-meta:';
            const EXPIRE_MS = 21 * 24 * 60 * 60 * 1000; // 3 weeks

            // list issues with the `taken` label (open issues only by default)
            const issuesResp = await github.rest.issues.listForRepo({
              owner,
              repo,
              labels: takenLabel,
              state: 'open',
              per_page: 100
            });

            for (const issue of (issuesResp.data || [])) {
              const issueNumber = issue.number;
              const commentsResp = await github.rest.issues.listComments({ owner, repo, issue_number: issueNumber, per_page: 200 });
              const comments = commentsResp.data || [];
              const botCommentsWithMarker = comments
                .filter(c => c.user && c.user.login === BOT_LOGIN && (c.body || '').includes(MARKER_PREFIX))
                .sort((a,b) => new Date(a.created_at) - new Date(b.created_at));
              if (!botCommentsWithMarker.length) continue;
              const latestBotComment = botCommentsWithMarker[botCommentsWithMarker.length - 1];
              try {
                const start = latestBotComment.body.indexOf(MARKER_PREFIX);
                const end = latestBotComment.body.indexOf('-->', start);
                const jsonText = latestBotComment.body.slice(start + MARKER_PREFIX.length, end).trim();
                const meta = JSON.parse(jsonText);
                if (meta && meta.owner && meta.ts && (Date.now() - meta.ts) > EXPIRE_MS) {
                  // expire it
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: takenLabel });
                  } catch (e) { /* ignore */ }
                  // create human-visible expiry comment
                  await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: `‚ö†Ô∏è The claim by @${meta.owner} has expired after 3 weeks of inactivity. The issue is now free to be taken.` });
                  // create a new bot meta comment resetting state (do NOT edit existing comments)
                  const newMeta = { owner: null, members: [], ts: 0 };
                  await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body: `${MARKER_PREFIX}${JSON.stringify(newMeta)} -->\n\nThis issue is currently unclaimed.` });
                }
              } catch (e) {
                // ignore parse errors for now
              }
            }
