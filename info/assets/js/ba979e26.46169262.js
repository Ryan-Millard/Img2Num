"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9254],{74710(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"internal/core/internal-code/graph/api","title":"Graph / Node API","description":"Each Node is a collection of pixels. A Node holds a unique_ptr to a vector of pixels with RGBXY structure. \\\\","source":"@site/docs/internal/core/internal-code/graph/api.md","sourceDirName":"internal/core/internal-code/graph","slug":"/internal/core/internal-code/graph/api","permalink":"/Img2Num/info/docs/next/internal/core/internal-code/graph/api","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/internal/core/internal-code/graph/api.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"api","title":"Graph / Node API","sidebar_label":"API / Usage","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Important Functions Explained","permalink":"/Img2Num/info/docs/next/internal/core/internal-code/graph/important-functions"},"next":{"title":".github","permalink":"/Img2Num/info/docs/next/internal/dot-github"}}');var d=i(86106),s=i(78634);const o={id:"api",title:"Graph / Node API",sidebar_label:"API / Usage",sidebar_position:5},r="Graph / Node API",l={},c=[{value:"Member Variables",id:"member-variables",level:2},{value:"Protected Members (Internal State)",id:"protected-members-internal-state",level:3},{value:"Public Members",id:"public-members",level:3},{value:"API Reference",id:"api-reference",level:2},{value:"1. Lifecycle",id:"1-lifecycle",level:3},{value:"<code>Node(int32_t id, std::unique_ptr&lt;std::vector&lt;RGBXY&gt;&gt; &amp;pixels)</code>",id:"nodeint32_t-id-stdunique_ptrstdvectorrgbxy-pixels",level:4},{value:"<code>void clear_all()</code>",id:"void-clear_all",level:4},{value:"2. Geometric &amp; Visual Properties",id:"2-geometric--visual-properties",level:3},{value:"<code>XY centroid() const</code>",id:"xy-centroid-const",level:4},{value:"<code>ImageLib::RGBPixel&lt;uint8_t&gt; color() const</code>",id:"imagelibrgbpixeluint8_t-color-const",level:4},{value:"<code>std::array&lt;int32_t, 4&gt; bounding_box_xywh() const</code>",id:"stdarrayint32_t-4-bounding_box_xywh-const",level:4},{value:"<code>size_t area() const</code>",id:"size_t-area-const",level:4},{value:"3. Graph Topology Management",id:"3-graph-topology-management",level:3},{value:"4. Image &amp; Contour Operations",id:"4-image--contour-operations",level:3},{value:"<code>std::array&lt;int, 4&gt; create_binary_image(std::vector&lt;uint8_t&gt; &amp;binary) const</code>",id:"stdarrayint-4-create_binary_imagestdvectoruint8_t-binary-const",level:4},{value:"<code>void compute_contour()</code>",id:"void-compute_contour",level:4},{value:"<code>void add_edge_pixel(const XY edge_pixel)</code>",id:"void-add_edge_pixelconst-xy-edge_pixel",level:4},{value:"<code>void clear_edge_pixels()</code>",id:"void-clear_edge_pixels",level:4},{value:"5. Data Access &amp; Modification",id:"5-data-access--modification",level:3},{value:"Member Variables",id:"member-variables-1",level:2},{value:"Protected Members (Internal State)",id:"protected-members-internal-state-1",level:3},{value:"1. Initialization",id:"1-initialization",level:3},{value:"<code>Graph(std::unique_ptr&lt;std::vector&lt;Node_ptr&gt;&gt; &amp;nodes, int width, int height)</code>",id:"graphstdunique_ptrstdvectornode_ptr-nodes-int-width-int-height",level:4},{value:"2. Topology Analysis (Edge Discovery)",id:"2-topology-analysis-edge-discovery",level:3},{value:"<code>void discover_edges(const std::vector&lt;int32_t&gt; &amp;region_labels, int32_t width, int32_t height)</code>",id:"void-discover_edgesconst-stdvectorint32_t-region_labels-int32_t-width-int32_t-height",level:4},{value:"<code>bool add_edge(int32_t node_id1, int32_t node_id2)</code>",id:"bool-add_edgeint32_t-node_id1-int32_t-node_id2",level:4},{value:"3. Graph Simplification (Merging &amp; Pruning)",id:"3-graph-simplification-merging--pruning",level:3},{value:"<code>bool merge_nodes(const Node_ptr &amp;node_to_keep, const Node_ptr &amp;node_to_remove)</code>",id:"bool-merge_nodesconst-node_ptr-node_to_keep-const-node_ptr-node_to_remove",level:4},{value:"<code>void merge_small_area_nodes(int32_t min_area)</code>",id:"void-merge_small_area_nodesint32_t-min_area",level:4},{value:"<code>void clear_unconnected_nodes()</code>",id:"void-clear_unconnected_nodes",level:4},{value:"4. Data Processing &amp; Access",id:"4-data-processing--access",level:3},{value:"<code>void compute_contours()</code>",id:"void-compute_contours",level:4},{value:"<code>const std::vector&lt;Node_ptr&gt; &amp;get_nodes() const</code>",id:"const-stdvectornode_ptr-get_nodes-const",level:4},{value:"<code>size_t size()</code>",id:"size_t-size",level:4},{value:"<code>bool all_areas_bigger_than(int32_t min_area)</code>",id:"bool-all_areas_bigger_thanint32_t-min_area",level:4}];function a(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.header,{children:(0,d.jsx)(n.h1,{id:"graph--node-api",children:"Graph / Node API"})}),"\n",(0,d.jsxs)(n.p,{children:["Each ",(0,d.jsx)(n.code,{children:"Node"})," is a collection of pixels. A ",(0,d.jsx)(n.code,{children:"Node"})," holds a ",(0,d.jsx)(n.code,{children:"unique_ptr"})," to a vector of pixels with ",(0,d.jsx)(n.code,{children:"RGBXY"})," structure. ",(0,d.jsx)(n.br,{}),"\n","Each pixel has its own color and position."]}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.code,{children:"Node"}),"s reference neighbors through node pointers (",(0,d.jsx)(n.code,{children:"shared_ptr"}),")"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",metastring:'title="Nodes reference neigbors through node shared pointers"',children:"Node_ptr n_ptr = std::make_shared<Node>(<id>, <std::unique_ptr<std::vector<RGBXY>> pixels>);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["A ",(0,d.jsx)(n.code,{children:"Graph"})," takes ownership over a collection of Nodes. It does so by referencing a list of Node pointers."]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",metastring:'title="A Graph takes ownership over a collection of Nodes. It does so by referencing a list of Node pointers."',children:"std::unique_ptr<std::vector<Node_ptr>> node_ptr =\n      std::make_unique<std::vector<Node_ptr>>(std::move(nodes));\nGraph G(node_ptr, width, height);\n"})}),"\n",(0,d.jsx)(n.admonition,{type:"tip",children:(0,d.jsxs)(n.p,{children:["In sum, ",(0,d.jsx)(n.code,{children:"Graph"}),"s manage a list of Nodes through their pointers. Each ",(0,d.jsx)(n.code,{children:"Node"})," can reference neighboring nodes as edges also through their pointers.\nSince multiple entities can reference the same ",(0,d.jsx)(n.code,{children:"Node"})," we use ",(0,d.jsx)(n.code,{children:"shared_ptr"}),"."]})}),"\n",(0,d.jsx)(n.h1,{id:"usage",children:"Usage"}),"\n",(0,d.jsxs)(n.p,{children:["This follows the step-by-step guide in the ",(0,d.jsx)(n.a,{href:"/Img2Num/info/docs/next/internal/core/internal-code/graph/explained",children:"explanation"}),"."]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsx)(n.li,{children:"Graph creation from kmeans labels"}),"\n"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"Initialize nodes and region map"}),"\n",(0,d.jsx)(n.li,{children:"Use floodfill to fill out the region map and construct nodes"}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"std::vector<int32_t> region_labels;\nstd::vector<Node_ptr> nodes;\n\nregion_labeling(image_data, kmeans_labels, region_labels, width, height, nodes);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["In ",(0,d.jsx)(n.code,{children:"region_labeling"})," each Node is assigned an id and a collections of pixels:"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"Node_ptr n_ptr = std::make_shared<Node>(r_lbl, p_ptr);\nnodes.push_back(n_ptr);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["Then initialize the ",(0,d.jsx)(n.code,{children:"Graph"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"std::unique_ptr<std::vector<Node_ptr>> node_ptr =\n      std::make_unique<std::vector<Node_ptr>>(std::move(nodes));\nGraph G(node_ptr, width, height);\n"})}),"\n",(0,d.jsxs)(n.p,{children:["Finally add edges between ",(0,d.jsx)(n.code,{children:"Nodes"}),":"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"G.discover_edges(region_labels, width, height);\n"})}),"\n",(0,d.jsxs)(n.ol,{start:"2",children:["\n",(0,d.jsx)(n.li,{children:"Merge small regions/nodes"}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"G.merge_small_area_nodes(min_area);\n"})}),"\n",(0,d.jsxs)(n.ol,{start:"3",children:["\n",(0,d.jsx)(n.li,{children:"Compute contours and manage gaps"}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-cpp",children:"G.compute_contours();\n"})}),"\n",(0,d.jsx)(n.p,{children:"In this function nodes are iterated over one at a time.\nPseudocode:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-text",children:"for node in G.nodes\n{\n    // Consider all neigbors\n    for neigbor in node.edges\n    {\n        // collect pixels for each neighbor\n    }\n    /*\n    1. Create joint grid plot of all pixels in node and neighbors\n    2. Find edge pixels\n    3. Decide if edge pixel should be added to the `node`'s or `neigbor`'s edge_pixel collection to ensure contour overlap\n    */\n}\n\nfor node in G.nodes\n{\n    // compute contour per node\n}\n"})}),"\n",(0,d.jsxs)(n.ol,{start:"4",children:["\n",(0,d.jsx)(n.li,{children:"Collect all contours for SVG export"}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h1,{id:"node-class-documentation",children:"Node Class Documentation"}),"\n",(0,d.jsx)(n.h2,{id:"member-variables",children:"Member Variables"}),"\n",(0,d.jsx)(n.h3,{id:"protected-members-internal-state",children:"Protected Members (Internal State)"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Variable Name"}),(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"m_id"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"int32_t"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:"Unique identifier for the node."})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"m_pixels"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"std::unique_ptr<std::vector<RGBXY>>"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:"Exclusive ownership of the raw pixel data defining this region."})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"m_edges"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"std::set<Node_ptr>"})}),(0,d.jsxs)(n.td,{style:{textAlign:"left"},children:["Adjacency list containing pointers to neighboring ",(0,d.jsx)(n.code,{children:"Node"})," objects."]})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"m_edge_pixels"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"std::set<XY>"})}),(0,d.jsxs)(n.td,{style:{textAlign:"left"},children:["Auxiliary pixels used for contour tracing. These are distinct from ",(0,d.jsx)(n.code,{children:"m_pixels"})," and do not affect color/area calculations."]})]})]})]}),"\n",(0,d.jsx)(n.h3,{id:"public-members",children:"Public Members"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Variable Name"}),(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,d.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,d.jsx)(n.tbody,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"m_contours"})}),(0,d.jsx)(n.td,{style:{textAlign:"left"},children:(0,d.jsx)(n.code,{children:"ColoredContours"})}),(0,d.jsxs)(n.td,{style:{textAlign:"left"},children:["Vector representation of the node boundaries. Populated only after calling ",(0,d.jsx)(n.code,{children:"compute_contour()"}),"."]})]})})]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h2,{id:"api-reference",children:"API Reference"}),"\n",(0,d.jsx)(n.h3,{id:"1-lifecycle",children:"1. Lifecycle"}),"\n",(0,d.jsx)(n.h4,{id:"nodeint32_t-id-stdunique_ptrstdvectorrgbxy-pixels",children:(0,d.jsx)(n.code,{children:"Node(int32_t id, std::unique_ptr<std::vector<RGBXY>> &pixels)"})}),"\n",(0,d.jsx)(n.p,{children:"Constructs a new Node."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"id:"})," The unique integer ID."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"pixels:"})," Reference to a unique pointer containing pixel data. Ownership is transferred to the Node using ",(0,d.jsx)(n.code,{children:"std::move"}),"."]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"void-clear_all",children:(0,d.jsx)(n.code,{children:"void clear_all()"})}),"\n",(0,d.jsx)(n.p,{children:"Resets the node completely, clearing pixel data, edges, and internal buffers."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"2-geometric--visual-properties",children:"2. Geometric & Visual Properties"}),"\n",(0,d.jsx)(n.h4,{id:"xy-centroid-const",children:(0,d.jsx)(n.code,{children:"XY centroid() const"})}),"\n",(0,d.jsx)(n.p,{children:"Calculates the geometric center of mass (average X, Y) of the region."}),"\n",(0,d.jsx)(n.h4,{id:"imagelibrgbpixeluint8_t-color-const",children:(0,d.jsx)(n.code,{children:"ImageLib::RGBPixel<uint8_t> color() const"})}),"\n",(0,d.jsxs)(n.p,{children:["Computes the representative color of the node (typically the average color of all pixels in ",(0,d.jsx)(n.code,{children:"m_pixels"}),")."]}),"\n",(0,d.jsx)(n.h4,{id:"stdarrayint32_t-4-bounding_box_xywh-const",children:(0,d.jsx)(n.code,{children:"std::array<int32_t, 4> bounding_box_xywh() const"})}),"\n",(0,d.jsx)(n.p,{children:"Calculates the axis-aligned bounding box."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Returns:"})," ",(0,d.jsx)(n.code,{children:"[min_x, min_y, width, height]"})]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"size_t-area-const",children:(0,d.jsx)(n.code,{children:"size_t area() const"})}),"\n",(0,d.jsx)(n.p,{children:"Returns the total number of pixels currently contained in the node."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"3-graph-topology-management",children:"3. Graph Topology Management"}),"\n",(0,d.jsxs)(n.p,{children:["Methods to manage the adjacency list (",(0,d.jsx)(n.code,{children:"m_edges"}),")."]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"void add_edge(const Node_ptr &node)"}),": Adds a connection to a neighbor."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"void remove_edge(const Node_ptr &node)"}),": Removes a specific connection."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"void remove_all_edges()"}),": Clears all connections (isolates the node)."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"const std::set<Node_ptr> &edges() const"}),": Returns a read-only reference to the neighbor set."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"size_t num_edges() const"}),": Returns the degree of the node."]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"4-image--contour-operations",children:"4. Image & Contour Operations"}),"\n",(0,d.jsx)(n.h4,{id:"stdarrayint-4-create_binary_imagestdvectoruint8_t-binary-const",children:(0,d.jsx)(n.code,{children:"std::array<int, 4> create_binary_image(std::vector<uint8_t> &binary) const"})}),"\n",(0,d.jsx)(n.p,{children:"Rasterizes the node into a binary mask."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"binary:"})," Output buffer where the mask is written."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Returns:"})," Array describing dimensions/offsets of the generated mask."]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"void-compute_contour",children:(0,d.jsx)(n.code,{children:"void compute_contour()"})}),"\n",(0,d.jsxs)(n.p,{children:["Calculates the vector contours of the node based on edge pixels and populates ",(0,d.jsx)(n.code,{children:"m_contours"}),"."]}),"\n",(0,d.jsx)(n.h4,{id:"void-add_edge_pixelconst-xy-edge_pixel",children:(0,d.jsx)(n.code,{children:"void add_edge_pixel(const XY edge_pixel)"})}),"\n",(0,d.jsx)(n.p,{children:"Adds a coordinate to the set used specifically for boundary tracing."}),"\n",(0,d.jsx)(n.h4,{id:"void-clear_edge_pixels",children:(0,d.jsx)(n.code,{children:"void clear_edge_pixels()"})}),"\n",(0,d.jsx)(n.p,{children:"Clears the temporary edge pixel buffer."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"5-data-access--modification",children:"5. Data Access & Modification"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"int32_t id() const"}),": Getter for the Node ID."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"const std::vector<RGBXY> &get_pixels() const"}),": Read-only access to the raw pixel vector."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"ColoredContours &get_contours()"}),": Mutable access to the contour data."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.code,{children:"void add_pixels(const std::vector<RGBXY> &new_pixels)"}),": Merges new pixels into the existing node."]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h1,{id:"graph-class-documentation",children:"Graph Class Documentation"}),"\n",(0,d.jsx)(n.h2,{id:"member-variables-1",children:"Member Variables"}),"\n",(0,d.jsx)(n.h3,{id:"protected-members-internal-state-1",children:"Protected Members (Internal State)"}),"\n",(0,d.jsxs)(n.table,{children:[(0,d.jsx)(n.thead,{children:(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.th,{children:"Variable Name"}),(0,d.jsx)(n.th,{children:"Type"}),(0,d.jsx)(n.th,{children:"Description"})]})}),(0,d.jsxs)(n.tbody,{children:[(0,d.jsxs)(n.tr,{children:[(0,d.jsxs)(n.td,{children:[(0,d.jsx)(n.code,{children:"m_width"}),", ",(0,d.jsx)(n.code,{children:"m_height"})]}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"int"})}),(0,d.jsx)(n.td,{children:"Dimensions of the original source image."})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"m_nodes"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"std::unique_ptr<std::vector<Node_ptr>>"})}),(0,d.jsx)(n.td,{children:"The collection of all nodes in the graph."})]}),(0,d.jsxs)(n.tr,{children:[(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"m_node_ids"})}),(0,d.jsx)(n.td,{children:(0,d.jsx)(n.code,{children:"std::unordered_map<int32_t, int32_t>"})}),(0,d.jsxs)(n.td,{children:["A lookup map linking ",(0,d.jsx)(n.code,{children:"Node ID"})," to ",(0,d.jsx)(n.code,{children:"Vector Index"})," for fast retrieval."]})]})]})]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"1-initialization",children:"1. Initialization"}),"\n",(0,d.jsx)(n.h4,{id:"graphstdunique_ptrstdvectornode_ptr-nodes-int-width-int-height",children:(0,d.jsx)(n.code,{children:"Graph(std::unique_ptr<std::vector<Node_ptr>> &nodes, int width, int height)"})}),"\n",(0,d.jsx)(n.p,{children:"Constructs the Graph."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"nodes:"})," A unique pointer to a vector of Node pointers."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Behavior:"})," The constructor calls ",(0,d.jsx)(n.code,{children:"std::move"})," on the ",(0,d.jsx)(n.code,{children:"nodes"})," argument, taking full ownership of the data. It also triggers ",(0,d.jsx)(n.code,{children:"hash_node_ids()"})," to build the internal lookup map."]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"2-topology-analysis-edge-discovery",children:"2. Topology Analysis (Edge Discovery)"}),"\n",(0,d.jsx)(n.h4,{id:"void-discover_edgesconst-stdvectorint32_t-region_labels-int32_t-width-int32_t-height",children:(0,d.jsx)(n.code,{children:"void discover_edges(const std::vector<int32_t> &region_labels, int32_t width, int32_t height)"})}),"\n",(0,d.jsx)(n.p,{children:"Iterates through a raster label image to find adjacent regions."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"region_labels:"})," A flattened vector where each value represents the Node ID that the pixel belongs to."]}),"\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Behavior:"})," Scans neighbors (8-connected) in the label map. If two adjacent pixels have different labels, an edge is added between the corresponding Nodes."]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"bool-add_edgeint32_t-node_id1-int32_t-node_id2",children:(0,d.jsx)(n.code,{children:"bool add_edge(int32_t node_id1, int32_t node_id2)"})}),"\n",(0,d.jsxs)(n.p,{children:["Manually creates a connection between two nodes identified by their IDs.\nCalls ",(0,d.jsx)(n.code,{children:"add_edge"})," for both Nodes"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Returns:"})," ",(0,d.jsx)(n.code,{children:"true"})," if the edge was successfully added, ",(0,d.jsx)(n.code,{children:"false"})," if nodes were not found."]}),"\n"]}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"3-graph-simplification-merging--pruning",children:"3. Graph Simplification (Merging & Pruning)"}),"\n",(0,d.jsx)(n.h4,{id:"bool-merge_nodesconst-node_ptr-node_to_keep-const-node_ptr-node_to_remove",children:(0,d.jsx)(n.code,{children:"bool merge_nodes(const Node_ptr &node_to_keep, const Node_ptr &node_to_remove)"})}),"\n",(0,d.jsxs)(n.p,{children:["Combines two nodes into one. Called by ",(0,d.jsx)(n.code,{children:"merge_small_area_nodes"}),"."]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:(0,d.jsx)(n.strong,{children:"Behavior:"})}),"\n"]}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["Transfers pixels and edges from ",(0,d.jsx)(n.code,{children:"node_to_remove"})," to ",(0,d.jsx)(n.code,{children:"node_to_keep"}),"."]}),"\n",(0,d.jsx)(n.li,{children:"Updates the topology of neighbors."}),"\n",(0,d.jsxs)(n.li,{children:["Removes ",(0,d.jsx)(n.code,{children:"node_to_remove"})," from the active graph."]}),"\n"]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Returns:"})," ",(0,d.jsx)(n.code,{children:"true"})," if merge successful."]}),"\n"]}),"\n",(0,d.jsx)(n.h4,{id:"void-merge_small_area_nodesint32_t-min_area",children:(0,d.jsx)(n.code,{children:"void merge_small_area_nodes(int32_t min_area)"})}),"\n",(0,d.jsxs)(n.p,{children:["Iteratively merges nodes smaller than ",(0,d.jsx)(n.code,{children:"min_area"}),' into their largest neighbors. This is used to clean up "speckle" noise or insignificant regions.']}),"\n",(0,d.jsx)(n.h4,{id:"void-clear_unconnected_nodes",children:(0,d.jsx)(n.code,{children:"void clear_unconnected_nodes()"})}),"\n",(0,d.jsx)(n.p,{children:"Removes nodes that have no edges (orphaned regions) from the internal list."}),"\n",(0,d.jsx)(n.hr,{}),"\n",(0,d.jsx)(n.h3,{id:"4-data-processing--access",children:"4. Data Processing & Access"}),"\n",(0,d.jsx)(n.h4,{id:"void-compute_contours",children:(0,d.jsx)(n.code,{children:"void compute_contours()"})}),"\n",(0,d.jsxs)(n.p,{children:["Iterates through all nodes in the graph and triggers their individual ",(0,d.jsx)(n.code,{children:"compute_contour()"})," methods."]}),"\n",(0,d.jsx)(n.h4,{id:"const-stdvectornode_ptr-get_nodes-const",children:(0,d.jsx)(n.code,{children:"const std::vector<Node_ptr> &get_nodes() const"})}),"\n",(0,d.jsx)(n.p,{children:"Returns a read-only reference to the underlying vector of nodes."}),"\n",(0,d.jsx)(n.h4,{id:"size_t-size",children:(0,d.jsx)(n.code,{children:"size_t size()"})}),"\n",(0,d.jsx)(n.p,{children:"Returns the number of nodes currently in the graph."}),"\n",(0,d.jsx)(n.h4,{id:"bool-all_areas_bigger_thanint32_t-min_area",children:(0,d.jsx)(n.code,{children:"bool all_areas_bigger_than(int32_t min_area)"})}),"\n",(0,d.jsx)(n.p,{children:"Utility check to verify if the graph simplification process (merging small nodes) is complete."}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsxs)(n.li,{children:[(0,d.jsx)(n.strong,{children:"Returns:"})," ",(0,d.jsx)(n.code,{children:"true"})," if every node in the graph has an area greater than ",(0,d.jsx)(n.code,{children:"min_area"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(a,{...e})}):a(e)}},78634(e,n,i){i.d(n,{R:()=>o,x:()=>r});var t=i(7378);const d={},s=t.createContext(d);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);