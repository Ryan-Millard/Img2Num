"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[1524],{11709:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"reference/wasm/modules/image/graph/important-functions","title":"Important Functions Explained","description":"Nodes are responsible in computing their own contours using the Suzuki-Abe method.","source":"@site/docs/reference/wasm/modules/image/graph/important-functions.md","sourceDirName":"reference/wasm/modules/image/graph","slug":"/reference/wasm/modules/image/graph/important-functions","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/graph/important-functions","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/reference/wasm/modules/image/graph/important-functions.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Important Functions Explained","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Graph and Node Explained","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/graph/explained"},"next":{"title":"API / Usage","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/graph/api"}}');var s=r(74848),i=r(28453);const l={title:"Important Functions Explained",sidebar_position:4},c="Suzuki-Abe Contour Tracing Algorithm",d={},o=[{value:"Key Concepts",id:"key-concepts",level:2},{value:"1. Border Types",id:"1-border-types",level:3},{value:"2. Tracking Variables",id:"2-tracking-variables",level:3},{value:"The Algorithm Steps",id:"the-algorithm-steps",level:2},{value:"Phase 1: Raster Scan",id:"phase-1-raster-scan",level:3},{value:"Phase 2: Border Following (The &quot;Turtle&quot; Logic)",id:"phase-2-border-following-the-turtle-logic",level:3},{value:"Hierarchy Tree Structure",id:"hierarchy-tree-structure",level:2},{value:"1. Geometric Primitives",id:"1-geometric-primitives",level:2},{value:"<code>struct Point</code>",id:"struct-point",level:3},{value:"<code>struct QuadBezier</code>",id:"struct-quadbezier",level:3},{value:"2. Contour Results",id:"2-contour-results",level:2},{value:"<code>struct ContoursResult</code>",id:"struct-contoursresult",level:3},{value:"Member Variables",id:"member-variables",level:4},{value:"Hierarchy Structure (<code>std::array&lt;int, 4&gt;</code>)",id:"hierarchy-structure-stdarrayint-4",level:4},{value:"3. Visual Extension",id:"3-visual-extension",level:2},{value:"<code>struct ColoredContours</code>",id:"struct-coloredcontours",level:3}];function h(e){const t={annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",math:"math",mi:"mi",mrow:"mrow",ol:"ol",p:"p",semantics:"semantics",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Nodes are responsible in computing their own contours using the Suzuki-Abe method."}),"\n",(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"suzuki-abe-contour-tracing-algorithm",children:"Suzuki-Abe Contour Tracing Algorithm"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Reference:"})," ",(0,s.jsx)(t.em,{children:'Suzuki, S. and Abe, K., "Topological Structural Analysis of Digitized Binary Images by Border Following", CVGIP 30 1, pp 32-46 (1985)'})]}),"\n",(0,s.jsx)(t.p,{children:"The Suzuki-Abe algorithm is a border-following technique designed to extract the topological structure of binary images. Unlike simple boundary tracing, it produces two distinct outputs:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Contours:"})," Vector lists of point coordinates representing the borders."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hierarchy:"})," A tree structure indicating the relationship between borders (e.g., is a border an external outline or a hole inside another shape?)."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsx)(t.h3,{id:"1-border-types",children:"1. Border Types"}),"\n",(0,s.jsx)(t.p,{children:"The algorithm distinguishes between two types of borders based on the transition between 0 (background) and 1 (foreground) pixels:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Outer Border:"})," The boundary between a background region and a foreground component (surrounded by background)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hole Border:"})," The boundary between a foreground component and an internal background hole (surrounded by foreground)."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"2-tracking-variables",children:"2. Tracking Variables"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:(0,s.jsx)(t.code,{children:"f[i,j]"})}),": The value of the pixel at row ",(0,s.jsx)(t.code,{children:"i"}),", column ",(0,s.jsx)(t.code,{children:"j"}),". Initially, the image contains only ",(0,s.jsx)(t.code,{children:"0"})," (background) and ",(0,s.jsx)(t.code,{children:"1"})," (foreground). As the algorithm runs, ",(0,s.jsx)(t.code,{children:"1"}),"s are replaced by unique Border IDs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"NBD"})," (Number of Border)"]}),": A counter representing the current Border ID being assigned. Starts at ",(0,s.jsx)(t.code,{children:"2"})," (since ",(0,s.jsx)(t.code,{children:"1"})," is used for raw foreground)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(t.code,{children:"LNBD"})," (Last Number of Border)"]}),': Tracks the Border ID of the most recently visited border during the raster scan. This acts as the "Parent" tracker.']}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"the-algorithm-steps",children:"The Algorithm Steps"}),"\n",(0,s.jsxs)(t.p,{children:["The algorithm combines a ",(0,s.jsx)(t.strong,{children:"Raster Scan"})," (to find new borders) with a ",(0,s.jsx)(t.strong,{children:"Border Following"})," routine (to trace and mark the entire boundary once found)."]}),"\n",(0,s.jsx)(t.h3,{id:"phase-1-raster-scan",children:"Phase 1: Raster Scan"}),"\n",(0,s.jsx)(t.p,{children:"Iterate through the image row by row, from top-left to bottom-right."}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["Reset ",(0,s.jsx)(t.code,{children:"LNBD"}),":"]})," At the start of every row, reset ",(0,s.jsx)(t.code,{children:"LNBD = 1"})," (frame ID)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["Check Pixel ",(0,s.jsx)(t.code,{children:"f[i,j]"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Case A (Outer Border Start):"})," If ",(0,s.jsx)(t.code,{children:"f[i,j] == 1"})," and ",(0,s.jsx)(t.code,{children:"f[i, j-1] == 0"})," (transition from empty space to object):","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Increment ",(0,s.jsx)(t.code,{children:"NBD"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["This is a new ",(0,s.jsx)(t.strong,{children:"Outer Border"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Update Hierarchy: ",(0,s.jsx)(t.code,{children:"LNBD"})," is the parent of ",(0,s.jsx)(t.code,{children:"NBD"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Trigger Phase 2 (Trace Border)"})," starting at ",(0,s.jsx)(t.code,{children:"(i,j)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Case B (Hole Border Start):"})," If ",(0,s.jsx)(t.code,{children:"f[i,j] >= 1"})," and ",(0,s.jsx)(t.code,{children:"f[i, j+1] == 0"})," (transition from object to empty space):","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Increment ",(0,s.jsx)(t.code,{children:"NBD"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["This is a new ",(0,s.jsx)(t.strong,{children:"Hole Border"}),"."]}),"\n",(0,s.jsxs)(t.li,{children:["Update Hierarchy: ",(0,s.jsx)(t.code,{children:"LNBD"})," is the parent of ",(0,s.jsx)(t.code,{children:"NBD"}),". (If ",(0,s.jsx)(t.code,{children:"f[i,j] > 1"}),", set ",(0,s.jsx)(t.code,{children:"LNBD = f[i,j]"})," first)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Trigger Phase 2 (Trace Border)"})," starting at ",(0,s.jsx)(t.code,{children:"(i,j)"}),"."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Case C (Non-Border):"})," If neither A nor B, update ",(0,s.jsx)(t.code,{children:"LNBD"})," if ",(0,s.jsx)(t.code,{children:"f[i,j] != 0"})," and continue scanning."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"phase-2-border-following-the-turtle-logic",children:'Phase 2: Border Following (The "Turtle" Logic)'}),"\n",(0,s.jsxs)(t.p,{children:["Once a starting pixel ",(0,s.jsx)(t.code,{children:"(x, y)"})," is found, trace the connected edge pixels until returning to the start."]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Search Neighborhood:"})," Starting from the previous pixel (or a default direction), check the 8-connected (or 4-connected) neighbors in a ",(0,s.jsx)(t.strong,{children:"Clockwise"})," (or Counter-Clockwise) direction."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Find Next Pixel:"})," The first non-zero pixel found becomes the next current pixel."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Mark Pixel:"})," Change the value of the current pixel in the image to ",(0,s.jsx)(t.code,{children:"NBD"})," (or ",(0,s.jsx)(t.code,{children:"-NBD"})," in specific cases to mark visited edges without destroying topology).","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.em,{children:"Note: This modification prevents the Raster Scan from re-detecting the same border later."})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Record Coordinate:"})," Add the pixel ",(0,s.jsx)(t.code,{children:"(x, y)"})," to the current contour vector."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Termination:"})," Stop when the tracer returns to the ",(0,s.jsx)(t.strong,{children:"Starting Point"})," AND matches the ",(0,s.jsx)(t.strong,{children:"Starting Direction"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"hierarchy-tree-structure",children:"Hierarchy Tree Structure"}),"\n",(0,s.jsxs)(t.p,{children:["The algorithm maintains a hierarchy table (often stored as an ",(0,s.jsx)(t.code,{children:"std::array<int, 4>"})," : ",(0,s.jsx)(t.code,{children:"[Next, Previous, First_Child, Parent]"}),")."]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Topology"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Root"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"The image frame (background)."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Parent"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"The border immediately surrounding the current one."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Child"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"A border immediately contained within the current one."})]})]})]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.strong,{children:"Example Hierarchy:"})}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Outer Box (ID 2)"})," -> Parent: Frame."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Inner Hole (ID 3)"})," -> Parent: ID 2."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Island inside Hole (ID 4)"})," -> Parent: ID 3."]}),"\n"]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h1,{id:"contour-data-structures",children:"Contour Data Structures"}),"\n",(0,s.jsx)(t.p,{children:"This file documents the core data structures used to represent vector boundaries, Bezier curves, and the topological hierarchy of image regions."}),"\n",(0,s.jsx)(t.h2,{id:"1-geometric-primitives",children:"1. Geometric Primitives"}),"\n",(0,s.jsx)(t.h3,{id:"struct-point",children:(0,s.jsx)(t.code,{children:"struct Point"})}),"\n",(0,s.jsx)(t.p,{children:"A fundamental 2D coordinate representing a position in the image space."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Member"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"x"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"float"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Horizontal coordinate (column). Uses ",(0,s.jsx)(t.code,{children:"float"})," to support sub-pixel precision or smooth vector coordinates."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"y"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"float"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Vertical coordinate (row)."})]})]})]}),"\n",(0,s.jsx)(t.h3,{id:"struct-quadbezier",children:(0,s.jsx)(t.code,{children:"struct QuadBezier"})}),"\n",(0,s.jsx)(t.p,{children:"Represents a Quadratic Bezier curve segment. This is used when the raw pixel contours are approximated or smoothed into vector paths."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Member"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"p0"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"Point"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:"Start Point:"})," The anchor point where the curve begins."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"p1"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"Point"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:"Control Point:"})," The handle that determines the curve's tangent and shape. The curve generally does not pass through this point."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"p2"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"Point"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.strong,{children:"End Point:"})," The anchor point where the curve ends."]})]})]})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"2-contour-results",children:"2. Contour Results"}),"\n",(0,s.jsx)(t.h3,{id:"struct-contoursresult",children:(0,s.jsx)(t.code,{children:"struct ContoursResult"})}),"\n",(0,s.jsx)(t.p,{children:"The primary container for the output of the contour extraction algorithm (e.g., Suzuki-Abe). It separates the raw pixel data from the topological relationship data."}),"\n",(0,s.jsx)(t.h4,{id:"member-variables",children:"Member Variables"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Member Variable"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"contours"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"vector<vector<Point>>"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["A list of contours. ",(0,s.jsx)(t.code,{children:"contours[k]"})," is a vector of ",(0,s.jsx)(t.code,{children:"Point"}),"s tracing the boundary of the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"k"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"-th region."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"curves"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"vector<vector<QuadBezier>>"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["A vectorized representation of ",(0,s.jsx)(t.code,{children:"contours"}),". ",(0,s.jsx)(t.code,{children:"curves[k]"})," contains the Bezier segments approximating the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"k"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"-th contour."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"hierarchy"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"vector<array<int, 4>>"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Topological tree structure describing how contours nest within each other (see ",(0,s.jsx)(t.strong,{children:"Hierarchy Structure"})," below)."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"is_hole"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"vector<bool>"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Flags the type of border. ",(0,s.jsx)(t.code,{children:"true"})," if ",(0,s.jsx)(t.code,{children:"contours[k]"})," is an internal hole; ",(0,s.jsx)(t.code,{children:"false"})," if it is an external boundary."]})]})]})]}),"\n",(0,s.jsxs)(t.h4,{id:"hierarchy-structure-stdarrayint-4",children:["Hierarchy Structure (",(0,s.jsx)(t.code,{children:"std::array<int, 4>"}),")"]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"hierarchy"})," vector follows the standard structure (compatible with OpenCV) to represent the nesting tree. For the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"k"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"-th contour, ",(0,s.jsx)(t.code,{children:"hierarchy[k]"})," contains:"]}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Index"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Name"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"0"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Next Sibling"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Index of the next contour at the same tree level. ",(0,s.jsx)(t.code,{children:"-1"})," if none."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"1"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Prev Sibling"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Index of the previous contour at the same tree level. ",(0,s.jsx)(t.code,{children:"-1"})," if none."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"2"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"First Child"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Index of the first contour nested ",(0,s.jsx)(t.em,{children:"inside"})," this contour. ",(0,s.jsx)(t.code,{children:"-1"})," if no children."]})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"3"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.strong,{children:"Parent"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Index of the contour that surrounds this contour. ",(0,s.jsx)(t.code,{children:"-1"})," if it is a root/frame contour."]})]})]})]}),"\n",(0,s.jsx)(t.hr,{}),"\n",(0,s.jsx)(t.h2,{id:"3-visual-extension",children:"3. Visual Extension"}),"\n",(0,s.jsx)(t.h3,{id:"struct-coloredcontours",children:(0,s.jsx)(t.code,{children:"struct ColoredContours"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"Inherits from:"})," ",(0,s.jsx)(t.code,{children:"ContoursResult"})]}),"\n",(0,s.jsx)(t.p,{children:"Extends the geometric data with visual attributes, specifically assigning a color to each contour. This is useful for visualization or when contours inherit the color properties of the underlying image nodes."}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Member Variable"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Type"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,s.jsx)(t.tbody,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"colors"})}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:(0,s.jsx)(t.code,{children:"vector<RGBAPixel<uint8_t>>"})}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["A parallel vector to ",(0,s.jsx)(t.code,{children:"contours"}),". ",(0,s.jsx)(t.code,{children:"colors[k]"})," holds the RGBA color associated with the ",(0,s.jsxs)(t.span,{className:"katex",children:[(0,s.jsx)(t.span,{className:"katex-mathml",children:(0,s.jsx)(t.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,s.jsxs)(t.semantics,{children:[(0,s.jsx)(t.mrow,{children:(0,s.jsx)(t.mi,{children:"k"})}),(0,s.jsx)(t.annotation,{encoding:"application/x-tex",children:"k"})]})})}),(0,s.jsx)(t.span,{className:"katex-html","aria-hidden":"true",children:(0,s.jsxs)(t.span,{className:"base",children:[(0,s.jsx)(t.span,{className:"strut",style:{height:"0.6944em"}}),(0,s.jsx)(t.span,{className:"mord mathnormal",style:{marginRight:"0.03148em"},children:"k"})]})})]}),"-th contour."]})]})})]})]})}function a(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,t,r)=>{r.d(t,{R:()=>l,x:()=>c});var n=r(96540);const s={},i=n.createContext(s);function l(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);