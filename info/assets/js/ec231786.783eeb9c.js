"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[2892],{2345:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"reference/wasm/modules/image/fft_iterative/overview","title":"Overview","description":"This page is a short overview of the iterative FFT implementation in src/wasm/modules/image.","source":"@site/docs/reference/wasm/modules/image/fft_iterative/overview.md","sourceDirName":"reference/wasm/modules/image/fft_iterative","slug":"/reference/wasm/modules/image/fft_iterative/overview","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/fft_iterative/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/reference/wasm/modules/image/fft_iterative/overview.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"overview","title":"Overview","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"fft_iterative.h","permalink":"/Img2Num/info/docs/reference/wasm/modules/image/fft_iterative"},"next":{"title":"Prerequisite Theory for FFTs","permalink":"/Img2Num/info/docs/category/prerequisite-theory-for-ffts"}}');var r=t(4848),s=t(8453);const a={id:"overview",title:"Overview",sidebar_position:2},o="FFT \u2014 Overview",l={},d=[{value:"Key capabilities",id:"key-capabilities",level:2},{value:"Important notes",id:"important-notes",level:2},{value:"Minimal usage (C++ style)",id:"minimal-usage-c-style",level:2}];function c(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"fft--overview",children:"FFT \u2014 Overview"})}),"\n",(0,r.jsxs)(i.p,{children:["This page is a short overview of the iterative FFT implementation in ",(0,r.jsx)(i.code,{children:"src/wasm/modules/image"}),"."]}),"\n",(0,r.jsxs)(i.p,{children:["The implementation provides a compact, iterative (non-recursive) FFT with utilities for 1D and 2D transforms. It is designed to be used in-place on ",(0,r.jsx)(i.code,{children:"std::vector<std::complex<double>>"})," buffers and includes small helpers for power-of-two padding and bit-reversal permutation."]}),"\n",(0,r.jsx)(i.h2,{id:"key-capabilities",children:"Key capabilities"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["In-place iterative FFT (",(0,r.jsx)(i.code,{children:"iterative_fft"}),") with optional inverse (normalizes on inverse)."]}),"\n",(0,r.jsxs)(i.li,{children:["Convenience wrappers that return new vectors (",(0,r.jsx)(i.code,{children:"fft_copy"}),", ",(0,r.jsx)(i.code,{children:"iterative_fft_2d_copy"}),")."]}),"\n",(0,r.jsxs)(i.li,{children:["2D FFT support via row/column transforms (",(0,r.jsx)(i.code,{children:"iterative_fft_2d"}),")."]}),"\n",(0,r.jsx)(i.li,{children:"Auto-padding to the next power of two when input length is not a power of two."}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"important-notes",children:"Important notes"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Inputs are ",(0,r.jsx)(i.code,{children:"std::complex<double>"})," vectors."]}),"\n",(0,r.jsx)(i.li,{children:"The implementation pads inputs to a power of two when needed (so output length may increase)."}),"\n",(0,r.jsxs)(i.li,{children:["Complexity is ",(0,r.jsx)(i.code,{children:"O(N log N)"})," for 1D transforms; 2D is handled via separable row/column FFTs."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"minimal-usage-c-style",children:"Minimal usage (C++ style)"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-cpp",children:'#include <complex>\n#include <vector>\n#include "fft_iterative.h"\n\nstd::vector<std::complex<double>> data = /* fill */;\n// forward FFT (in-place)\n//    data: signal in spatial domain\n//    2nd argument: direction\n//      false: transform to frequency domain\n//      true:  transform to spatial domain\nfft::iterative_fft(data, false);\n// data is now in frequency domain\n\n// inverse FFT (in-place)\nfft::iterative_fft(data, true);\n// data is back to spatial domain\n\n// 2D example (width/height known)\nfft::iterative_fft_2d(data, width, height, false);\n// data is now in frequency domain\n'})}),"\n",(0,r.jsxs)(i.p,{children:["For details, see the source file\n",(0,r.jsx)(i.a,{href:"https://github.com/Ryan-Millard/Img2Num/blob/main/src/wasm/modules/image/src/fft_iterative.cpp",children:(0,r.jsx)(i.code,{children:"fft_iterative.cpp"})}),"\nand its header\n",(0,r.jsx)(i.a,{href:"https://github.com/Ryan-Millard/Img2Num/blob/main/src/wasm/modules/image/include/fft_iterative.h",children:(0,r.jsx)(i.code,{children:"fft_iterative.h"})}),"."]})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>o});var n=t(6540);const r={},s=n.createContext(r);function a(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);