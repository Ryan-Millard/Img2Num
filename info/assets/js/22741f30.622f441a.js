"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[9102],{72801(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"reference/react/components/Tooltip/tests","title":"Tests","description":"This page documents the Vitest test suite for the Tooltip component and provides guidance for writing reliable tests,","source":"@site/docs/reference/react/components/Tooltip/tests.md","sourceDirName":"reference/react/components/Tooltip","slug":"/reference/react/components/Tooltip/tests","permalink":"/Img2Num/info/docs/next/reference/react/components/Tooltip/tests","draft":false,"unlisted":false,"editUrl":"https://github.com/Ryan-Millard/Img2Num/edit/main/docs/docs/reference/react/components/Tooltip/tests.md","tags":[],"version":"current","frontMatter":{"title":"Tests"},"sidebar":"tutorialSidebar","previous":{"title":"Tooltip","permalink":"/Img2Num/info/docs/next/reference/react/components/Tooltip/"},"next":{"title":"Pagination","permalink":"/Img2Num/info/docs/next/category/pagination"}}');var t=s(74848),o=s(28453);const r={title:"Tests"},l=void 0,c={},d=[{value:"Individual Test Explanations",id:"individual-test-explanations",level:2},{value:"Basic Behavior Tests",id:"basic-behavior-tests",level:3},{value:"Touch Device Behavior Tests",id:"touch-device-behavior-tests",level:3},{value:"Event Handler Preservation Tests",id:"event-handler-preservation-tests",level:3},{value:"Common Flakiness and Fixes",id:"common-flakiness-and-fixes",level:2},{value:"Testing Recommendations",id:"testing-recommendations",level:2}];function a(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["This page documents the Vitest test suite for the ",(0,t.jsx)(n.code,{children:"Tooltip"})," component and provides guidance for writing reliable tests,\nincluding for keyboard accessibility and portal behavior."]}),"\n",(0,t.jsx)(n.h2,{id:"individual-test-explanations",children:"Individual Test Explanations"}),"\n",(0,t.jsx)(n.h3,{id:"basic-behavior-tests",children:"Basic Behavior Tests"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"does not show tooltip content by default"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Ensures the tooltip is not rendered until user interaction.\n",(0,t.jsx)(n.code,{children:"react-tooltip"})," appends the tooltip node to ",(0,t.jsx)(n.code,{children:"document.body"}),", accessible via ",(0,t.jsx)(n.code,{children:"screen"})," queries in jsdom."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"shows tooltip on hover"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"userEvent.hover"})," triggers pointer events. The tooltip library mounts the tooltip node in response."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"hides tooltip when mouse leaves"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Uses ",(0,t.jsx)(n.code,{children:"waitFor()"})," to accommodate any hide delays or CSS transitions."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"shows tooltip on keyboard focus"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Tests accessibility: the tooltip appears when the trigger element receives keyboard focus."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"hides tooltip when focus leaves"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Confirms the tooltip hides when the trigger loses focus. ",(0,t.jsx)(n.code,{children:"waitFor()"})," ensures the test accounts for any hide transition delays."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"touch-device-behavior-tests",children:"Touch Device Behavior Tests"}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"detects touch device and shows tooltip on click"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mocks ",(0,t.jsx)(n.code,{children:"navigator.maxTouchPoints"})," to simulate a touch device."]}),"\n",(0,t.jsx)(n.li,{children:"Verifies that clicking/tapping the trigger element shows the tooltip."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"auto-hides tooltip after 1 second on touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Uses real timers with ",(0,t.jsx)(n.code,{children:"setTimeout"})," and ",(0,t.jsx)(n.code,{children:"new Promise"})," to wait for the 1-second auto-hide."]}),"\n",(0,t.jsx)(n.li,{children:"Verifies tooltip appears on click, then disappears after 1 second (1100ms wait with 100ms buffer)."}),"\n",(0,t.jsx)(n.li,{children:"Test timeout set to 7000ms to accommodate the real timer wait."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"does not show tooltip on click for non-touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mocks ",(0,t.jsx)(n.code,{children:"navigator.maxTouchPoints = 0"})," to simulate a desktop device."]}),"\n",(0,t.jsx)(n.li,{children:"Confirms that clicking doesn't automatically show the tooltip (hover/focus still work)."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"shows tooltip on focus for touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Verifies that focusing an element (e.g., via Tab key) shows the tooltip on touch devices."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"auto-hides tooltip after 1 second on focus for touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Uses real timers with ",(0,t.jsx)(n.code,{children:"setTimeout"})," to verify auto-hide after focus."]}),"\n",(0,t.jsx)(n.li,{children:"Tooltip triggered by focus also auto-hides after 1 second on touch devices."}),"\n",(0,t.jsx)(n.li,{children:"Test timeout set to 7000ms to accommodate the real timer wait."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"event-handler-preservation-tests",children:"Event Handler Preservation Tests"}),"\n",(0,t.jsxs)(n.ol,{start:"11",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"calls both existing onClick and showTooltip on touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Tests that existing ",(0,t.jsx)(n.code,{children:"onClick"})," handlers on child elements are preserved."]}),"\n",(0,t.jsxs)(n.li,{children:["Uses ",(0,t.jsx)(n.code,{children:"vi.fn()"})," to verify the existing handler is called."]}),"\n",(0,t.jsx)(n.li,{children:"Also verifies the tooltip still appears on touch devices."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"preserves existing onClick when no touch device"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Confirms that on non-touch devices, existing onClick handlers still work correctly."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"works with non-element children wrapper on touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Tests the ",(0,t.jsx)(n.code,{children:"<span>"})," wrapper case when plain text or non-element children are passed."]}),"\n",(0,t.jsx)(n.li,{children:"Verifies click behavior works on the wrapper element."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"preserves existing onFocus handler on touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Tests that existing ",(0,t.jsx)(n.code,{children:"onFocus"})," handlers are preserved and called."]}),"\n",(0,t.jsx)(n.li,{children:"Verifies both the handler and tooltip logic execute on touch devices."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"preserves existing onFocus handler on non-touch devices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Confirms that onFocus handlers work correctly on non-touch devices."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-flakiness-and-fixes",children:"Common Flakiness and Fixes"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Portal timing / animations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"react-tooltip"})," may delay mounting/unmounting for animations.\nWrap visibility assertions in ",(0,t.jsx)(n.code,{children:"await waitFor()"})," or use ",(0,t.jsx)(n.code,{children:"findBy*"})," queries to retry until the tooltip appears/disappears:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-js",children:'expect(await screen.findByText("Hello tooltip")).toBeVisible();\nawait waitFor(() => expect(screen.queryByText("Hello tooltip")).not.toBeInTheDocument());\n'})}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"You can also disable CSS transitions in test setup for deterministic results."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Missing jsdom environment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Tooltip"})," renders portals to ",(0,t.jsx)(n.code,{children:"document.body"}),". Ensure Vitest is running with ",(0,t.jsx)(n.code,{children:"environment: 'jsdom'"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event ordering"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Always use ",(0,t.jsx)(n.code,{children:"userEvent.setup()"})," and ",(0,t.jsx)(n.code,{children:"await"})," interactions. Avoid manually firing low-level events unless necessary."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Double focus / tab issues"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["When testing tooltips on interactive elements, pass a single focusable element (e.g., ",(0,t.jsx)(n.code,{children:"<button>"})," or ",(0,t.jsx)(n.code,{children:"<Link>"}),")\nas ",(0,t.jsx)(n.code,{children:"children"}),". If the component wraps non-element children in a ",(0,t.jsx)(n.code,{children:"<span tabIndex={0}>"}),", account for that extra tab stop in tests."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"React strict mode / act warnings"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Vitest + Testing Library usually handles ",(0,t.jsx)(n.code,{children:"act()"})," automatically. Ensure ",(0,t.jsx)(n.code,{children:"globals: true"})," in your test setup and keep dependencies updated."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Timer-based behavior (touch device auto-hide)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The tests use ",(0,t.jsx)(n.strong,{children:"real timers"})," with ",(0,t.jsx)(n.code,{children:"setTimeout"})," and ",(0,t.jsx)(n.code,{children:"new Promise"})," for waiting (not fake timers)."]}),"\n",(0,t.jsxs)(n.li,{children:["For auto-hide assertions, wait with ",(0,t.jsx)(n.code,{children:"await new Promise((resolve) => setTimeout(resolve, 1100))"})," (1-second timeout + 100ms buffer)."]}),"\n",(0,t.jsxs)(n.li,{children:["Set test timeout to at least 7000ms (",(0,t.jsx)(n.code,{children:"test(..., 7000)"}),") to accommodate real timer waits."]}),"\n",(0,t.jsx)(n.li,{children:"This approach avoids complexity with fake timer setup and queryClient/React re-renders."}),"\n",(0,t.jsxs)(n.li,{children:["If you prefer fake timers, you can use ",(0,t.jsx)(n.code,{children:"vi.useFakeTimers()"}),", ",(0,t.jsx)(n.code,{children:"vi.advanceTimersByTime(1000)"}),", and ",(0,t.jsx)(n.code,{children:"vi.useRealTimers()"}),", but ensure proper cleanup to avoid affecting other tests."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mocking navigator properties"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Mock ",(0,t.jsx)(n.code,{children:"navigator.maxTouchPoints"})," using ",(0,t.jsx)(n.code,{children:"Object.defineProperty"})," with ",(0,t.jsx)(n.code,{children:"configurable: true"})," and ",(0,t.jsx)(n.code,{children:"writable: true"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Set value to ",(0,t.jsx)(n.code,{children:"1"})," or higher for touch devices, ",(0,t.jsx)(n.code,{children:"0"})," for non-touch devices."]}),"\n",(0,t.jsxs)(n.li,{children:["Reset mocks in ",(0,t.jsx)(n.code,{children:"afterEach"})," with ",(0,t.jsx)(n.code,{children:"vi.restoreAllMocks()"})," to avoid affecting other tests."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"testing-recommendations",children:"Testing Recommendations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Always test tooltips attached to ",(0,t.jsx)(n.strong,{children:"real interactive elements"})," (buttons, links, ",(0,t.jsx)(n.code,{children:"<Link>"})," from react-router-dom) to avoid duplicate tab stops."]}),"\n",(0,t.jsxs)(n.li,{children:["When testing external links or non-focusable nodes, account for the optional wrapper ",(0,t.jsx)(n.code,{children:"<span tabIndex={0}>"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"findBy*"})," for asserting tooltip visibility; it retries until the tooltip appears."]}),"\n",(0,t.jsxs)(n.li,{children:["Wrap hide assertions in ",(0,t.jsx)(n.code,{children:"waitFor()"})," to accommodate CSS transitions or delayed unmounts."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"For touch device tests:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use real timers with ",(0,t.jsx)(n.code,{children:"setTimeout"})," and ",(0,t.jsx)(n.code,{children:"new Promise"})," for auto-hide testing (simpler and more reliable)."]}),"\n",(0,t.jsxs)(n.li,{children:["Wait for auto-hide with: ",(0,t.jsx)(n.code,{children:"await new Promise((resolve) => setTimeout(resolve, 1100))"})," (1 second timeout + 100ms buffer)."]}),"\n",(0,t.jsxs)(n.li,{children:["Set test timeout to 7000ms or higher: ",(0,t.jsx)(n.code,{children:'test("test name", async () => {...}, 7000)'})," to allow time for real timer waits."]}),"\n",(0,t.jsxs)(n.li,{children:["Mock ",(0,t.jsx)(n.code,{children:"navigator.maxTouchPoints"})," appropriately for each test case (saved/restored via ",(0,t.jsx)(n.code,{children:"beforeEach"}),"/",(0,t.jsx)(n.code,{children:"afterEach"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Alternative: Use fake timers (",(0,t.jsx)(n.code,{children:"vi.useFakeTimers()"}),", ",(0,t.jsx)(n.code,{children:"vi.advanceTimersByTime()"}),", ",(0,t.jsx)(n.code,{children:"vi.useRealTimers()"}),") if you prefer deterministic time control."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"For event handler preservation:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"vi.fn()"})," to create mock handlers and verify they're called."]}),"\n",(0,t.jsxs)(n.li,{children:["Test both ",(0,t.jsx)(n.code,{children:"onClick"})," and ",(0,t.jsx)(n.code,{children:"onFocus"})," handlers to ensure they're preserved."]}),"\n",(0,t.jsx)(n.li,{children:"Test both touch and non-touch device scenarios to ensure handlers work in both cases."}),"\n",(0,t.jsx)(n.li,{children:"Verify that both the existing handler and tooltip logic execute when applicable."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},28453(e,n,s){s.d(n,{R:()=>r,x:()=>l});var i=s(96540);const t={},o=i.createContext(t);function r(e){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);